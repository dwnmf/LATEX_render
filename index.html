<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Markdown + LaTeX Studio">
  <link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj48cmVjdCB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgZmlsbD0iIzBmMTEwZiIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBzdHlsZT0iZm9udC1mYW1pbHk6IEFyaWFsOyBmb250LXNpemU6IDgwcHg7IGZpbGw6ICMxNGYxOTU7IHRleHQtYW5jaG9yOiBtaWRkbGU7IGRvbWluYW50LWJhc2VsaW5lOiBtaWRkbGU7Ij5NTDwvdGV4dD48L3N2Zz4=">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Golos+Text:wght@400;500;600;700&family=Manrope:wght@600;700;800&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
  <title>Markdown + LaTeX Studio</title>
  <style>
    :root {
      --color-bg: #111616;
      --color-bg-top: #121717;
      --color-bg-elevated: #171d1d;
      --color-surface: #1d2424;
      --color-surface-strong: #232b2b;
      --color-border: #394343;
      --color-border-strong: #556262;
      --color-text: #f2f6f6;
      --color-text-secondary: #c3cdcd;
      --color-text-muted: #8e9a9a;
      --color-accent: #f2f7f7;
      --color-accent-strong: #ffffff;
      --color-danger: #f25f5c;
      --color-link: #dbe6ff;
      --color-link-hover: #ffffff;
      --font-display: "Manrope", "Segoe UI", sans-serif;
      --font-sans: "Golos Text", "Segoe UI", sans-serif;
      --font-mono: "JetBrains Mono", "Consolas", monospace;
      --shadow-hard: 4px 4px 0 rgba(0, 0, 0, 0.55);
      --shadow-focus: 0 0 0 2px rgba(255, 255, 255, 0.38);
      --bg-glow: rgba(255, 255, 255, 0.08);
      --grid-line: rgba(255, 255, 255, 0.05);
      --panel-actions-bg: rgba(0, 0, 0, 0.16);
      --panel-help-bg: rgba(0, 0, 0, 0.12);
      --button-bg: #252e2e;
      --button-bg-hover: #313b3b;
      --button-text: #f2f6f6;
      --render-btn-text: #101515;
      --code-text: #e9fff7;
      --inline-code-bg: #141919;
      --block-code-bg: #141919;
      --table-head-bg: #1b2222;
      --media-bg: #1b2222;
      --scroll-track: #151a1a;
      --scroll-thumb: #556060;
      --scroll-thumb-hover: #667575;
      --flow-current-text: #131919;
      --flow-approved-fill: #5c6666;
      --flow-approved-text: #f0f4f4;
      --flow-past-fill: #3b4141;
      --flow-past-text: #f2f6f6;
      --flow-future-fill: #2a3131;
      --flow-future-text: #f2f6f6;
      --flow-invalid-fill: #a33f3d;
      --flow-invalid-text: #f8d9d8;
      --flow-rejected-fill: #6d3736;
      --flow-rejected-text: #ffd6d5;
      --space-1: 4px;
      --space-2: 8px;
      --space-3: 12px;
      --space-4: 16px;
      --space-5: 20px;
      --space-6: 24px;
      --space-8: 32px;
    }

    html[data-theme="light"] {
      --color-bg: #e8eded;
      --color-bg-top: #f7f9f9;
      --color-bg-elevated: #f3f6f6;
      --color-surface: #ffffff;
      --color-surface-strong: #f7f9f9;
      --color-border: #bcc5c5;
      --color-border-strong: #7e8a8a;
      --color-text: #111616;
      --color-text-secondary: #3f4949;
      --color-text-muted: #687575;
      --color-accent: #111616;
      --color-accent-strong: #000000;
      --color-danger: #b5332f;
      --color-link: #1f3e77;
      --color-link-hover: #132b54;
      --shadow-hard: 4px 4px 0 rgba(18, 24, 24, 0.16);
      --shadow-focus: 0 0 0 2px rgba(17, 22, 22, 0.25);
      --bg-glow: rgba(0, 0, 0, 0.06);
      --grid-line: rgba(16, 22, 22, 0.05);
      --panel-actions-bg: rgba(0, 0, 0, 0.04);
      --panel-help-bg: rgba(0, 0, 0, 0.03);
      --button-bg: #eef2f2;
      --button-bg-hover: #dde4e4;
      --button-text: #111616;
      --render-btn-text: #f2f7f7;
      --code-text: #1d2727;
      --inline-code-bg: #eef2f2;
      --block-code-bg: #edf2f2;
      --table-head-bg: #e8eded;
      --media-bg: #e8eded;
      --scroll-track: #e4eaea;
      --scroll-thumb: #95a4a4;
      --scroll-thumb-hover: #7f9090;
      --flow-current-text: #f2f7f7;
      --flow-approved-fill: #c4cece;
      --flow-approved-text: #1b2323;
      --flow-past-fill: #d7e0e0;
      --flow-past-text: #152020;
      --flow-future-fill: #ecf2f2;
      --flow-future-text: #152020;
      --flow-invalid-fill: #e7b8b6;
      --flow-invalid-text: #3b1615;
      --flow-rejected-fill: #e9c7c5;
      --flow-rejected-text: #3b1817;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      min-height: 100%;
    }

    html {
      color-scheme: dark;
      font-size: 16px;
      -webkit-text-size-adjust: 100%;
    }

    html[data-theme="light"] {
      color-scheme: light;
    }

    body {
      font-family: var(--font-sans);
      color: var(--color-text);
      background:
        radial-gradient(circle at top right, var(--bg-glow) 0%, rgba(255, 255, 255, 0) 42%),
        linear-gradient(160deg, var(--color-bg-top) 0%, var(--color-bg) 100%);
      line-height: 1.5;
      position: relative;
      overflow-x: hidden;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      opacity: 0.08;
      background-image:
        linear-gradient(var(--grid-line) 1px, transparent 1px),
        linear-gradient(90deg, var(--grid-line) 1px, transparent 1px);
      background-size: 40px 40px;
      z-index: -1;
    }

    .container {
      width: min(1740px, calc(100% - 20px));
      margin: 0 auto;
      padding: var(--space-5) 0 var(--space-4);
    }

    header {
      margin-bottom: var(--space-4);
    }

    h1 {
      margin: 0;
      font-family: var(--font-display);
      font-size: clamp(1.85rem, 3.3vw, 2.8rem);
      font-weight: 800;
      line-height: 1.04;
      letter-spacing: -0.04em;
      text-transform: uppercase;
      color: var(--color-text);
    }

    .subtitle {
      margin: 8px 0 0;
      font-size: clamp(0.9rem, 1.4vw, 1rem);
      color: var(--color-text-secondary);
      max-width: 920px;
    }

    .editor-container {
      display: grid;
      grid-template-columns: minmax(380px, 1fr) minmax(380px, 1fr);
      gap: var(--space-4);
      align-items: start;
    }

    .editor-container.input-collapsed {
      grid-template-columns: minmax(0, 1fr);
    }

    .input-area,
    .output-container {
      border: 2px solid var(--color-border-strong);
      background: linear-gradient(180deg, var(--color-surface-strong) 0%, var(--color-surface) 100%);
      box-shadow: var(--shadow-hard);
      min-width: 0;
    }

    .input-area {
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-height: calc(100vh - 118px);
    }

    textarea {
      width: 100%;
      border: 0;
      border-bottom: 2px solid var(--color-border);
      background: var(--color-bg-elevated);
      color: var(--color-text);
      min-height: 62vh;
      height: calc(100vh - 238px);
      padding: 14px;
      font-family: var(--font-mono);
      font-size: 0.92rem;
      line-height: 1.55;
      resize: vertical;
      outline: none;
      font-variant-ligatures: none;
    }

    textarea:focus {
      box-shadow: inset var(--shadow-focus);
    }

    .actions {
      padding: 10px 12px;
      border-bottom: 2px solid var(--color-border);
      background: var(--panel-actions-bg);
    }

    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
    }

    button {
      border: 2px solid var(--color-border-strong);
      background: var(--button-bg);
      color: var(--button-text);
      padding: 9px 14px;
      font-family: var(--font-display);
      font-size: 0.77rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.11em;
      cursor: pointer;
      transition: transform 120ms ease, background-color 120ms ease, border-color 120ms ease, color 120ms ease;
    }

    button:hover {
      transform: translate(-2px, -2px);
      border-color: var(--color-text);
      background: var(--button-bg-hover);
    }

    button:active {
      transform: translate(0, 0);
    }

    button:focus-visible {
      outline: none;
      box-shadow: var(--shadow-focus);
    }

    #renderBtn {
      background: var(--color-accent);
      border-color: var(--color-accent);
      color: var(--render-btn-text);
    }

    #renderBtn:hover {
      background: var(--color-accent-strong);
      border-color: var(--color-accent-strong);
      color: var(--render-btn-text);
    }

    .help-text {
      display: none;
      margin: 0;
      padding: 8px 12px 10px;
      color: var(--color-text-secondary);
      font-size: 0.83rem;
      line-height: 1.45;
      background: var(--panel-help-bg);
    }

    .help-text.is-visible {
      display: block;
    }

    .input-area.is-collapsed {
      min-height: auto;
    }

    .input-area.is-collapsed textarea {
      display: none;
    }

    .input-area.is-collapsed .help-text {
      display: none !important;
    }

    .input-area.is-collapsed .actions {
      border-bottom: 0;
    }

    .help-text strong {
      color: var(--color-text);
      font-weight: 700;
    }

    .help-text code {
      display: inline-block;
      padding: 1px 6px;
      border: 1px solid var(--color-border-strong);
      background: rgba(0, 0, 0, 0.35);
      font-family: var(--font-mono);
      font-size: 0.8rem;
    }

    .output-container {
      padding: 14px;
      max-height: calc(100vh - 118px);
      overflow: auto;
      font-size: 0.98rem;
      word-break: break-word;
    }

    .placeholder {
      margin: 0;
      color: var(--color-text-secondary);
      font-size: 0.95rem;
    }

    .render-error {
      margin: 0;
      padding: var(--space-3);
      border: 2px solid var(--color-danger);
      color: #ffd5d4;
      background: rgba(242, 95, 92, 0.12);
      font-weight: 700;
    }

    .output-container > *:first-child {
      margin-top: 0;
    }

    .output-container > *:last-child {
      margin-bottom: 0;
    }

    .output-container h1,
    .output-container h2,
    .output-container h3,
    .output-container h4,
    .output-container h5,
    .output-container h6 {
      font-family: var(--font-display);
      line-height: 1.15;
      margin-top: 1.5em;
      margin-bottom: 0.6em;
      text-transform: uppercase;
      letter-spacing: -0.015em;
      color: var(--color-text);
    }

    .output-container h1,
    .output-container h2 {
      border-bottom: 2px solid var(--color-border-strong);
      padding-bottom: 0.28em;
    }

    .output-container h1 {
      font-size: 1.8rem;
    }

    .output-container h2 {
      font-size: 1.45rem;
    }

    .output-container h3 {
      font-size: 1.2rem;
    }

    .output-container p,
    .output-container li,
    .output-container td {
      color: var(--color-text);
    }

    .output-container ul,
    .output-container ol {
      padding-left: 1.3rem;
    }

    .output-container li {
      margin-bottom: 0.35rem;
    }

    .output-container blockquote {
      margin-left: 0;
      margin-right: 0;
      border-left: 3px solid var(--color-accent);
      padding: 12px 14px;
      background: rgba(255, 255, 255, 0.08);
      color: var(--color-text-secondary);
    }

    .output-container a {
      color: var(--color-link);
      text-decoration-thickness: 2px;
      text-underline-offset: 2px;
    }

    .output-container a:hover {
      color: var(--color-link-hover);
    }

    .output-container code {
      font-family: var(--font-mono);
      font-size: 0.86em;
      border: 1px solid var(--color-border-strong);
      background: var(--inline-code-bg);
      padding: 1px 6px;
      color: var(--code-text);
    }

    .output-container pre {
      font-family: var(--font-mono);
      border: 2px solid var(--color-border);
      background: var(--block-code-bg);
      padding: 12px;
      overflow-x: auto;
      line-height: 1.6;
    }

    .output-container pre code {
      border: 0;
      background: transparent;
      padding: 0;
      color: inherit;
      font-size: inherit;
    }

    .output-container table {
      border-collapse: collapse;
      border: 2px solid var(--color-border-strong);
      width: 100%;
      margin: 1.1rem 0;
    }

    .output-container th,
    .output-container td {
      border: 1px solid var(--color-border);
      padding: 9px 10px;
      text-align: left;
      vertical-align: top;
    }

    .output-container thead th {
      background: var(--table-head-bg);
      font-family: var(--font-display);
      font-size: 0.78rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .output-container hr {
      border: 0;
      border-top: 2px solid var(--color-border-strong);
      margin: 1.6rem 0;
    }

    .output-container img {
      max-width: 100%;
      border: 2px solid var(--color-border);
      display: block;
      margin: 1rem auto;
      background: var(--media-bg);
    }

    .latex-display,
    .flowchart-container {
      border: 2px solid var(--color-border);
      background: var(--block-code-bg);
      padding: 10px;
      margin: 1.2rem 0;
      overflow: auto;
    }

    .flowchart-container svg {
      max-width: 100%;
      height: auto;
    }

    .flowchart-container svg .flowchart-node {
      stroke: var(--color-border-strong) !important;
      stroke-width: 2px !important;
    }

    .flowchart-container svg .flowchart-text {
      fill: var(--color-text) !important;
      font-family: var(--font-sans) !important;
      font-size: 13px !important;
    }

    .flowchart-container svg .flowchart-line {
      stroke: var(--color-border-strong) !important;
      stroke-width: 2px !important;
    }

    .flowchart-container svg .flowchart-arrow {
      fill: var(--color-border-strong) !important;
    }

    .output-container mjx-container[jax="SVG"] svg g[fill] {
      fill: var(--color-text) !important;
    }

    .output-container mjx-container[jax="SVG"] svg g[stroke] {
      stroke: var(--color-text) !important;
    }

    ::-webkit-scrollbar {
      width: 12px;
      height: 12px;
    }

    ::-webkit-scrollbar-track {
      background: var(--scroll-track);
      border: 1px solid var(--color-border);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--scroll-thumb);
      border: 2px solid var(--scroll-track);
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--scroll-thumb-hover);
    }

    @media (max-width: 1160px) {
      .editor-container {
        grid-template-columns: 1fr;
      }

      .input-area,
      .output-container {
        min-height: unset;
        max-height: unset;
      }

      textarea {
        min-height: 340px;
        height: 45vh;
      }
    }

    @media (max-width: 720px) {
      .container {
        width: calc(100% - 24px);
        padding: 12px 0;
      }

      h1 {
        font-size: clamp(1.55rem, 8.3vw, 2.2rem);
      }

      .button-group button {
        flex: 1 1 calc(50% - 8px);
      }

      .button-group button#printPDFBtn {
        flex-basis: 100%;
      }

      .button-group button#toggleHelpBtn,
      .button-group button#toggleEditorBtn,
      .button-group button#toggleThemeBtn {
        flex-basis: 100%;
      }

      textarea {
        min-height: 280px;
        height: 44vh;
      }
    }

    @media print {
      body::before,
      header,
      .input-area {
        display: none !important;
      }

      body {
        background: #ffffff !important;
        color: #000000 !important;
      }

      .container {
        width: 100%;
        margin: 0;
        padding: 0;
      }

      .editor-container {
        display: block;
      }

      .output-container {
        border: 0 !important;
        box-shadow: none !important;
        background: #ffffff !important;
        color: #000000 !important;
        max-height: none !important;
        overflow: visible !important;
        padding: 0 !important;
      }

      .output-container *,
      .output-container code,
      .output-container pre {
        color: #000000 !important;
        border-color: #999999 !important;
        background: transparent !important;
        box-shadow: none !important;
      }

      .output-container a {
        color: #0000ee !important;
      }

      .output-container a[href^="http"]::after {
        content: " (" attr(href) ")";
        font-size: 9pt;
      }
    }
  </style>

  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true,
        tags: 'ams',
        packages: {'[+]': ['ams', 'boldsymbol', 'newcommand']}
      },
      svg: {
        fontCache: 'global'
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
        ignoreHtmlClass: 'tex2jax_ignore',
        processHtmlClass: 'tex2jax_process'
      }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" id="MathJax-script" async></script>
  <script src="https://cdn.jsdelivr.net/npm/marked@4.2.12/marked.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.3.0/raphael.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.17.1/flowchart.min.js"></script>
</head>
<body>
  <div class="container">
    <header>
      <h1>Markdown + LaTeX Studio</h1>
      <p class="subtitle">Жёсткий Markdown/LaTeX редактор с тёмной и светлой темой, ASCII flowchart и моментальным рендером.</p>
    </header>

    <div class="editor-container">
      <section class="input-area">
        <textarea id="inputMessage" placeholder="Введите Markdown, LaTeX ($...$, $$...$$, \(...\), \[...\], \begin{env}...\end{env}) и блоки ```flowchart ... ```">## Пример

Это **Markdown** текст.

- Элемент 1
- Элемент 2

Встроенный LaTeX: $E=mc^2$ и \( \hbar = \frac{h}{2\pi} \).

Блочная формула:
$$
\sum_{i=1}^{n} i^2 = \frac{n(n+1)(2n+1)}{6}
$$

Комбинаторика:
$C(n, k) = \binom{n}{k}$

Flowchart:
```flowchart
st=>start: Старт |past
op=>operation: Шаг
cond=>condition: Готово?
e=>end: Выход |current

st->op->cond
cond(yes)->e
cond(no)->op
```</textarea>

        <div class="actions">
          <div class="button-group">
            <button id="renderBtn">Рендер</button>
            <button id="clearBtn">Очистить</button>
            <button id="printPDFBtn">Экспорт PDF</button>
            <button id="toggleEditorBtn" aria-expanded="true">Свернуть ввод</button>
            <button id="toggleHelpBtn" aria-expanded="false">Справка</button>
            <button id="toggleThemeBtn" aria-pressed="false">Тема: Тёмная</button>
          </div>
        </div>

        <p class="help-text" id="helpText" aria-hidden="true">
          Поддерживаются <strong>Markdown</strong>, <strong>LaTeX</strong> и <strong>flowchart</strong>.
          Быстрый рендер: <strong>Ctrl+Enter</strong> (или <strong>Cmd+Enter</strong>).
        </p>
      </section>

      <section class="output-container" id="output">
        <p class="placeholder">Введите текст и нажмите «Рендер».</p>
      </section>
    </div>
  </div>

  <script>
    const inputElement = document.getElementById("inputMessage");
    const outputElement = document.getElementById("output");
    const renderBtn = document.getElementById("renderBtn");
    const clearBtn = document.getElementById("clearBtn");
    const printPDFBtn = document.getElementById("printPDFBtn");
    const toggleEditorBtn = document.getElementById("toggleEditorBtn");
    const toggleHelpBtn = document.getElementById("toggleHelpBtn");
    const toggleThemeBtn = document.getElementById("toggleThemeBtn");
    const helpTextElement = document.getElementById("helpText");
    const inputAreaElement = document.querySelector(".input-area");
    const editorContainerElement = document.querySelector(".editor-container");

    const EMPTY_MESSAGE = "Введите текст и нажмите «Рендер».";
    const TOKEN_PREFIX = "@@LATEX_RENDERER_TOKEN";
    const THEME_KEY = "latex_renderer_theme";
    const INPUT_COLLAPSE_KEY = "latex_renderer_input_collapsed";
    const HELP_VISIBILITY_KEY = "latex_renderer_help_visible";
    let renderVersion = 0;

    renderBtn.addEventListener("click", renderContent);
    clearBtn.addEventListener("click", clearContent);
    printPDFBtn.addEventListener("click", printToPDF);
    toggleEditorBtn.addEventListener("click", toggleInputVisibility);
    toggleHelpBtn.addEventListener("click", toggleHelpVisibility);
    toggleThemeBtn.addEventListener("click", toggleTheme);
    inputElement.addEventListener("keydown", handleSubmitShortcut);

    function createToken(type, index) {
      return `${TOKEN_PREFIX}_${type}_${index}@@`;
    }

    function normalizeTheme(theme) {
      return theme === "light" ? "light" : "dark";
    }

    function setTheme(theme) {
      const normalizedTheme = normalizeTheme(theme);
      document.documentElement.setAttribute("data-theme", normalizedTheme);
      toggleThemeBtn.textContent = normalizedTheme === "light" ? "Тема: Светлая" : "Тема: Тёмная";
      toggleThemeBtn.setAttribute("aria-pressed", normalizedTheme === "light" ? "true" : "false");

      try {
        localStorage.setItem(THEME_KEY, normalizedTheme);
      } catch (error) {
        console.warn("Не удалось сохранить тему:", error);
      }
    }

    function toggleTheme() {
      const activeTheme = normalizeTheme(document.documentElement.getAttribute("data-theme"));
      setTheme(activeTheme === "dark" ? "light" : "dark");
      renderFlowcharts();
    }

    function setInputCollapsed(collapsed) {
      editorContainerElement.classList.toggle("input-collapsed", collapsed);
      inputAreaElement.classList.toggle("is-collapsed", collapsed);
      toggleEditorBtn.setAttribute("aria-expanded", collapsed ? "false" : "true");
      toggleEditorBtn.textContent = collapsed ? "Развернуть ввод" : "Свернуть ввод";

      try {
        localStorage.setItem(INPUT_COLLAPSE_KEY, collapsed ? "1" : "0");
      } catch (error) {
        console.warn("Не удалось сохранить состояние окна ввода:", error);
      }
    }

    function toggleInputVisibility() {
      const isCollapsed = inputAreaElement.classList.contains("is-collapsed");
      setInputCollapsed(!isCollapsed);
    }

    function setHelpVisibility(visible) {
      if (visible) {
        helpTextElement.classList.add("is-visible");
      } else {
        helpTextElement.classList.remove("is-visible");
      }

      toggleHelpBtn.setAttribute("aria-expanded", visible ? "true" : "false");
      helpTextElement.setAttribute("aria-hidden", visible ? "false" : "true");
      toggleHelpBtn.textContent = visible ? "Скрыть справку" : "Справка";
      try {
        localStorage.setItem(HELP_VISIBILITY_KEY, visible ? "1" : "0");
      } catch (error) {
        console.warn("Не удалось сохранить настройку справки:", error);
      }
    }

    function toggleHelpVisibility() {
      const isVisible = helpTextElement.classList.contains("is-visible");
      setHelpVisibility(!isVisible);
    }

    function escapeRegExp(value) {
      return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function escapeHtml(value) {
      return value
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function normalizeBinomialInMath(source) {
      return source.replace(
        /(^|[^\\])C\(\s*([^,()]+?)\s*,\s*([^)]+?)\s*\)/g,
        (match, prefix, n, k) => `${prefix}\\binom{${n.trim()}}{${k.trim()}}`
      );
    }

    function extractSegments(source) {
      const flowchartBlocks = [];
      const codeBlocks = [];
      const mathBlocks = [];
      let text = source;

      text = text.replace(/```(?:flowchart|flow)[ \t]*\r?\n([\s\S]*?)```/gi, (match, content) => {
        const token = createToken("FLOW", flowchartBlocks.length);
        flowchartBlocks.push({ token, content: content.trim() });
        return `\n${token}\n`;
      });

      text = text.replace(/```[ \t]*([a-zA-Z0-9_-]*)[ \t]*\r?\n[\s\S]*?```/g, (match) => {
        const token = createToken("CODE", codeBlocks.length);
        codeBlocks.push({ token, content: match });
        return token;
      });

      text = text.replace(/`[^`\r\n]+`/g, (match) => {
        const token = createToken("CODE", codeBlocks.length);
        codeBlocks.push({ token, content: match });
        return token;
      });

      function stashMath(pattern, display) {
        text = text.replace(pattern, (match) => {
          const token = createToken("MATH", mathBlocks.length);
          mathBlocks.push({
            token,
            content: normalizeBinomialInMath(match),
            display
          });
          return display ? `\n${token}\n` : token;
        });
      }

      stashMath(/(?<!\\)\$\$[\s\S]+?(?<!\\)\$\$/g, true);
      stashMath(/\\\[[\s\S]*?\\\]/g, true);
      stashMath(/\\begin\{(equation\*?|align\*?|gather\*?|multline\*?|alignat\*?|flalign\*?|cases|matrix|pmatrix|bmatrix|Bmatrix|vmatrix|Vmatrix|smallmatrix|split)\}[\s\S]*?\\end\{\1\}/g, true);
      stashMath(/\\\([\s\S]*?\\\)/g, false);
      stashMath(/(?<!\\)\$(?!\$)(?:\\.|[^\\$\r\n])+(?<!\\)\$/g, false);

      codeBlocks.forEach((block) => {
        text = text.split(block.token).join(block.content);
      });

      return { markdown: text, mathBlocks, flowchartBlocks };
    }

    function buildHtml(markdown, mathBlocks, flowchartBlocks, version) {
      const markedOptions = {
        mangle: false,
        headerIds: false,
        breaks: false,
        gfm: true
      };

      let html = marked.parse(markdown, markedOptions);

      mathBlocks.forEach((block, index) => {
        if (block.display) {
          const wrappedPattern = new RegExp(`<p>\\s*${escapeRegExp(block.token)}\\s*<\\/p>`, "g");
          html = html.replace(
            wrappedPattern,
            `<div class="latex-display tex2jax_process" data-math-index="${index}">${block.content}</div>`
          );
        }

        html = html.split(block.token).join(block.content);
      });

      flowchartBlocks.forEach((block, index) => {
        const containerId = `flowchart-${version}-${index}`;
        const replacement = `<div id="${containerId}" class="flowchart-container" data-flowchart="${encodeURIComponent(block.content)}"></div>`;
        const wrappedPattern = new RegExp(`<p>\\s*${escapeRegExp(block.token)}\\s*<\\/p>`, "g");
        html = html.replace(wrappedPattern, replacement);
        html = html.split(block.token).join(replacement);
      });

      return html;
    }

    async function typesetMath() {
      if (!window.MathJax || !window.MathJax.typesetPromise) {
        return;
      }

      if (typeof window.MathJax.typesetClear === "function") {
        window.MathJax.typesetClear([outputElement]);
      }

      await window.MathJax.typesetPromise([outputElement]);
    }

    function renderFlowcharts() {
      const containers = outputElement.querySelectorAll(".flowchart-container");
      const rootStyle = getComputedStyle(document.documentElement);
      const fontFamily = rootStyle.getPropertyValue("--font-sans").trim() || "Golos Text, sans-serif";
      const textColor = rootStyle.getPropertyValue("--color-text").trim() || "#e7ecec";
      const lineColor = rootStyle.getPropertyValue("--color-border-strong").trim() || "#3a4242";
      const fillColor = rootStyle.getPropertyValue("--color-surface").trim() || "#101212";
      const accentColor = rootStyle.getPropertyValue("--color-accent").trim() || "#f2f7f7";
      const flowCurrentTextColor = rootStyle.getPropertyValue("--flow-current-text").trim() || "#131919";
      const flowPastFill = rootStyle.getPropertyValue("--flow-past-fill").trim() || "#3b4141";
      const flowPastText = rootStyle.getPropertyValue("--flow-past-text").trim() || textColor;
      const flowFutureFill = rootStyle.getPropertyValue("--flow-future-fill").trim() || "#2a3131";
      const flowFutureText = rootStyle.getPropertyValue("--flow-future-text").trim() || textColor;
      const flowInvalidFill = rootStyle.getPropertyValue("--flow-invalid-fill").trim() || "#a33f3d";
      const flowInvalidText = rootStyle.getPropertyValue("--flow-invalid-text").trim() || "#f8d9d8";
      const flowApprovedFill = rootStyle.getPropertyValue("--flow-approved-fill").trim() || "#5c6666";
      const flowApprovedText = rootStyle.getPropertyValue("--flow-approved-text").trim() || "#f0f4f4";
      const flowRejectedFill = rootStyle.getPropertyValue("--flow-rejected-fill").trim() || "#6d3736";
      const flowRejectedText = rootStyle.getPropertyValue("--flow-rejected-text").trim() || "#ffd6d5";

      containers.forEach((container) => {
        const encoded = container.getAttribute("data-flowchart");
        if (!encoded) {
          return;
        }

        const source = decodeURIComponent(encoded);
        container.innerHTML = "";

        try {
          const diagram = flowchart.parse(source);
          diagram.drawSVG(container, {
            "line-width": 2,
            "line-length": 48,
            "text-margin": 12,
            "font-size": 13,
            "font-family": fontFamily,
            "font-color": textColor,
            "line-color": lineColor,
            "element-color": lineColor,
            fill: fillColor,
            "yes-text": "Да",
            "no-text": "Нет",
            "arrow-end": "block",
            scale: 1,
            symbols: {
              start: { class: "flowchart-node start" },
              end: { class: "flowchart-node end" },
              operation: { class: "flowchart-node operation" },
              inputoutput: { class: "flowchart-node io" },
              subroutine: { class: "flowchart-node sub" },
              condition: { class: "flowchart-node condition" }
            },
            flowstate: {
              past: { fill: flowPastFill, "font-color": flowPastText },
              current: { fill: accentColor, "font-color": flowCurrentTextColor, "font-weight": "bold" },
              future: { fill: flowFutureFill, "font-color": flowFutureText },
              invalid: { fill: flowInvalidFill, "font-color": flowInvalidText },
              approved: { fill: flowApprovedFill, "font-color": flowApprovedText },
              rejected: { fill: flowRejectedFill, "font-color": flowRejectedText }
            }
          });
        } catch (error) {
          const escapedSource = escapeHtml(source);
          const escapedError = escapeHtml(error.message || "Неизвестная ошибка");
          container.innerHTML = `<pre class="flowchart">${escapedSource}</pre><p class="render-error">Ошибка рендера flowchart: ${escapedError}</p>`;
        }
      });
    }

    async function renderContent() {
      const source = inputElement.value;
      const currentScroll = outputElement.scrollTop;
      const currentVersion = ++renderVersion;

      if (!source.trim()) {
        outputElement.innerHTML = `<p class="placeholder">${EMPTY_MESSAGE}</p>`;
        return;
      }

      try {
        const { markdown, mathBlocks, flowchartBlocks } = extractSegments(source);
        const html = buildHtml(markdown, mathBlocks, flowchartBlocks, currentVersion);
        outputElement.innerHTML = html;

        await typesetMath();
        if (currentVersion !== renderVersion) {
          return;
        }

        renderFlowcharts();
      } catch (error) {
        const message = escapeHtml(error.message || "Неизвестная ошибка");
        outputElement.innerHTML = `<p class="render-error">Ошибка рендера: ${message}</p>`;
      } finally {
        outputElement.scrollTop = currentScroll;
      }
    }

    function clearContent() {
      inputElement.value = "";
      outputElement.innerHTML = `<p class="placeholder">${EMPTY_MESSAGE}</p>`;
      inputElement.focus();
    }

    function handleSubmitShortcut(event) {
      if ((event.ctrlKey || event.metaKey) && event.key === "Enter") {
        event.preventDefault();
        renderContent();
      }
    }

    function printToPDF() {
      const cleanedOutput = outputElement.textContent.replace(/\s+/g, " ").trim();
      if (!cleanedOutput || cleanedOutput === EMPTY_MESSAGE) {
        alert("Сначала отрендерьте содержимое.");
        return;
      }
      window.print();
    }

    document.addEventListener("DOMContentLoaded", () => {
      let storedTheme = "dark";
      try {
        storedTheme = localStorage.getItem(THEME_KEY) || "dark";
      } catch (error) {
        console.warn("Не удалось прочитать тему:", error);
      }
      setTheme(storedTheme);

      let storedInputCollapse = "0";
      try {
        storedInputCollapse = localStorage.getItem(INPUT_COLLAPSE_KEY) || "0";
      } catch (error) {
        console.warn("Не удалось прочитать состояние окна ввода:", error);
      }
      setInputCollapsed(storedInputCollapse === "1");

      let storedHelpVisibility = "0";
      try {
        storedHelpVisibility = localStorage.getItem(HELP_VISIBILITY_KEY) || "0";
      } catch (error) {
        console.warn("Не удалось прочитать настройку справки:", error);
      }
      setHelpVisibility(storedHelpVisibility === "1");

      if (inputElement.value.trim()) {
        renderContent();
      } else {
        outputElement.innerHTML = `<p class="placeholder">${EMPTY_MESSAGE}</p>`;
      }
    });
  </script>
</body>
</html>
